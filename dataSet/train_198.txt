datetime                            2022-07-11 08:12:55-01:00
commit               038d5338530411bb47283fda1e84dec91137880b
repo                                               localstack
filepath                 localstack\aws\handlers\analytics.py
content     b'import logging\nimport threading\nfrom typin...
methods                   [__call__, __init__, _get_err_type]
lines       [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14...

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 

import logging
import threading
from typing import Optional

from localstack import config
from localstack.aws.api import RequestContext
from localstack.aws.chain import HandlerChain
from localstack.aws.client import parse_response
from localstack.http import Response
from localstack.utils.analytics.service_request_aggregator import (
    ServiceRequestAggregator,
    ServiceRequestInfo,
)

LOG = logging.getLogger(__name__)


class ServiceRequestCounter:

    aggregator: ServiceRequestAggregator

    def __init__(self, service_request_aggregator: ServiceRequestAggregator = None):
        self.aggregator = service_request_aggregator or ServiceRequestAggregator()
        self._mutex = threading.Lock()
        self._started = False

    def __call__(self, chain: HandlerChain, context: RequestContext, response: Response):
        if response is None or context.operation is None:
            return
        if config.DISABLE_EVENTS:
            return

        # this condition will only be true only for the first call, so it makes sense to not acquire the lock every time
        if not self._started:
            with self._mutex:
                if not self._started:
                    self._started = True
                    self.aggregator.start()

        err_type = self._get_err_type(context, response) if response.status_code >= 400 else None
        service_name = context.operation.service_model.service_name
        operation_name = context.operation.name

        self.aggregator.add_request(
            ServiceRequestInfo(
                service_name,
                operation_name,
                response.status_code,
                err_type=err_type,
            )
        )

    def _get_err_type(self, context: RequestContext, response: Response) -> Optional[str]:
        """
        Attempts to parse and return the error type from the response body, e.g. ResourceInUseException.

        TODO: we need this type of logic frequently, so we should make sure the parsed response is re-usable by
         multiple handlers, either by storing it in the context or the chain.
        """
        try:
            parsed_response = parse_response(context.operation, response)
            return parsed_response["Error"]["Code"]
        except Exception:
            if config.DEBUG_ANALYTICS:
                LOG.exception("error parsing error response")
            return None
